<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: pause_n_latch_and_synchroniser_tb</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_pause_n_latch_and_synchroniser_tb'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_pause_n_latch_and_synchroniser_tb')">pause_n_latch_and_synchroniser_tb</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt"><a href="mod6.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Toggle" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod6.html#Assert" >100.00</a></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/aparlane/fiuba_thesis/hdl/components/iso_iec_14443A/verification/vcs/../../verification/tb/pause_n_latch_and_synchroniser_tb.sv')">/home/aparlane/fiuba_thesis/hdl/components/iso_iec_14443A/verification/vcs/../../verification/tb/pause_n_latch_and_synchroniser_tb.sv</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod6.html#inst_tag_7"  onclick="showContent('inst_tag_7')">pause_n_latch_and_synchroniser_tb</a></td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt"><a href="mod6.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Toggle" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod6.html#Assert" >100.00</a></td>
</tr></table></div>
</div>
<br clear=all>
<div name='tag_pause_n_latch_and_synchroniser_tb'>
<hr>
<a name="inst_tag_7"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_7" >pause_n_latch_and_synchroniser_tb</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt"><a href="mod6.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Toggle" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod6.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod6.html#Assert" >100.00</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s9 cl rt"> 99.70</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 98.81</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<span class=inst>none</span>
<br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod11.html#inst_tag_13" id="tag_urg_inst_13">analogue_sim_inst</a></td>
<td class="s9 cl rt"> 99.38</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 98.15</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_8" id="tag_urg_inst_8">dut</a></td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
<hr>
Since this is the module's only instance, the coverage report is the same as for the module.</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_pause_n_latch_and_synchroniser_tb'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod6.html" >pause_n_latch_and_synchroniser_tb</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s10"><td class="lf">TOTAL</td><td></td><td>69</td><td>69</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>74</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>78</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>103</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>118</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>198</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>250</td><td>54</td><td>54</td><td>100.00</td></tr>
</table>
<pre class="code"><br clear=all>
73                          always @(posedge pause_n_async) begin
74         1/1                  async_deasserted_at &lt;= $time;
75                          end
76                      
77                          always @(posedge pause_n_synchronised) begin
78         1/1                  automatic longint deassert_delay = $time - async_deasserted_at;
79                      
80         1/1                  if (!rst_n) begin
81                                  // this deassert is because we're in reset
82                                  // ignore it
83                              end
84                              else begin
85         1/1                      if (deassert_delay &lt; min_time_between_deasserts) begin
86         1/1                          min_time_between_deasserts &lt;= deassert_delay;
87                                  end
                        MISSING_ELSE
88         1/1                      if (deassert_delay &gt; max_time_between_deasserts) begin
89         1/1                          max_time_between_deasserts &lt;= deassert_delay;
90                                  end
                        MISSING_ELSE
91                              end
92                          end
93                      
94                          // --------------------------------------------------------------
95                          // Helper functions / tasks
96                          // --------------------------------------------------------------
97                      
98                          // we don't really care what data we send here, just need a pause
99                          task send_data;
100                             static SendTransType trans = new('{PCDBitSequence_Z});
101                     
102                             // send it
103        1/1                  send_queue.push_back(trans);
104                     
105                             // wait for it to be done: 3 bit times @ 128 ticks each, plus a bit:
106                             //  PCDBitSequence_Z (SOC)      - 1 bit time
107                             //  idle time to enforce EOC    - 2 bit time
108        1/1                  analogue_sim_inst.driver.wait_for_idle(4*128 + 10);
109                         endtask
110                     
111                         function void randomise_params(logic stop_clock);
112                             int pcd_pause_len;
113                             int pause_n_asserts_after_ps;
114                             int pause_n_deasserts_after_ps;
115                             int clock_stops_after_ps;
116                             int clock_starts_after_ps;
117                     
118        1/1                  std::randomize(pcd_pause_len,
119                                            pause_n_asserts_after_ps, pause_n_deasserts_after_ps,
120                                            clock_stops_after_ps, clock_starts_after_ps)
121                             with
122                             {
123                                 // ISO/IEC 14443-2A:2016 section 8.1.2.1
124                                 // figure 3 and table 4. PCD pause length is T1. The time from when it starts
125                                 // transmitting a pause until it starts stopping to transmit a pause.
126                                 // My DUT shouldn't care about this length though, so I've increased the tested
127                                 // range. This gives more flexibility to the other parameters, ensuring we test
128                                 // larger ranges of those.
129                                 pcd_pause_len &gt;= 10;
130                                 pcd_pause_len &lt;= 50;
131                     
132                                 // The AFE must detect the pause before the PCD finishes transmitting it.
133                                 // Otherwise the amplitude of the carrier wave will start to rise and the AFE
134                                 // may not detect the pause at all.
135                                 // This constraint is also required for my pause_detect model to work correctly.
136                                 pause_n_asserts_after_ps &gt;= 0;
137                                 pause_n_asserts_after_ps &lt; (pcd_pause_len*CLOCK_PERIOD_PS);
138                     
139                                 // The upper bound on this is that the end of the pause has to come before the
140                                 // start of the pause of the next sequence. Which means at most 64 - pcd_pause_len
141                                 // ticks (for an X-&gt;Z (error)). Minus up to 3 ticks more for the synchroniser.
142                                 // However that would be pretty extreme if pcd_pause_len were on the lower end
143                                 // (64 - 10 - 3 = 51). When simulating Fabricio's SPICE model the largest delay I
144                                 // found here was ~600ns which is just over 8 ticks. I'm using 2us here as an
145                                 // upper bound, which is about 27 ticks, that's plenty of flexibility.
146                                 pause_n_deasserts_after_ps &gt;= 0;
147                                 pause_n_deasserts_after_ps &lt; 2*1000*1000;
148                                 pause_n_deasserts_after_ps &lt; (64 - pcd_pause_len - 3)*CLOCK_PERIOD_PS;
149                     
150                                 // When simulating Fabricio's SPICE model I always saw the clock stoping before
151                                 // the pause asserted. This may not be the case in the design when it's ported
152                                 // to the new fabrication process, but it seems reasonable, and the closer this
153                                 // simulation matches reality the better.
154                                 // At the very least it must be &lt; pcd_pause_len*CLOCK_PERIOD_PS, in order for the
155                                 // clock_recovery model to work correctly.
156                                 clock_stops_after_ps &gt;= 0;
157                                 clock_stops_after_ps &lt; pause_n_asserts_after_ps;
158                     
159                                 // Like pause_n_deasserts_after_ps, the only upper bound on the clock starting again
160                                 // is that it should occur before the next pause starts. I constrain it to the same
161                                 // range as pause_n_deasserts_after_ps (2us).
162                                 clock_starts_after_ps &gt;= 0;
163                                 clock_starts_after_ps &lt; 2*1000*1000;
164                                 clock_starts_after_ps &lt; (64 - pcd_pause_len - 3)*CLOCK_PERIOD_PS;
165                     
166                                 // there's some simulation errors where we get the wrong number of ticks
167                                 // if the clock/pause starts/stops exactly on an edge. So make sure that doesn't happen
168                                 (clock_stops_after_ps*2 % CLOCK_PERIOD_PS) != 0;
169                                 (clock_starts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
170                                 (pause_n_asserts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
171                                 (pause_n_deasserts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
172                             };
173                     
174                             /* $display(&quot;\nUsing:&quot;);
175                             $display(&quot;  PCD pause length     %d ticks&quot;, pcd_pause_len);
176                             $display(&quot;  pause_n_asserts_after   %d ps&quot;, pause_n_asserts_after_ps);
177                             $display(&quot;  pause_n_deasserts_after %d ps&quot;, pause_n_deasserts_after_ps);
178                             $display(&quot;  clock_stops_after       %d ps&quot;, clock_stops_after_ps);
179                             $display(&quot;  clock_starts_after      %d ps&quot;, clock_starts_after_ps);
180                             $display(&quot;========================================&quot;); */
181                     
182        1/1                  analogue_sim_inst.set_pause_ticks(pcd_pause_len);
183        1/1                  analogue_sim_inst.set_params(.clock_stops                   (stop_clock),
184                                                          .clock_stops_after_ps          (clock_stops_after_ps),
185                                                          .clock_starts_after_ps         (clock_starts_after_ps),
186                                                          .pause_n_asserts_after_ps      (pause_n_asserts_after_ps),
187                                                          .pause_n_deasserts_after_ps    (pause_n_deasserts_after_ps));
188                         endfunction
189                     
190                         // Constrain the parameters to our requirements for the AFE
191                         function void randomise_params_afe();
192                             int pcd_pause_len;
193                             int pause_n_asserts_after_ps;
194                             int pause_n_deasserts_after_ps;
195                             int clock_stops_after_ps;
196                             int clock_starts_after_ps;
197                     
198        1/1                  std::randomize(pcd_pause_len,
199                                            pause_n_asserts_after_ps, pause_n_deasserts_after_ps,
200                                            clock_stops_after_ps, clock_starts_after_ps)
201                             with
202                             {
203                                 // ISO/IEC 14443-2A:2016 section 8.1.2.1
204                                 // figure 3 and table 4. PCD pause length is T1. The time from when it starts
205                                 // transmitting a pause until it starts stopping to transmit a pause.
206                                 // My DUT shouldn't care about this length though, so I've increased the tested
207                                 // range. This gives more flexibility to the other parameters, ensuring we test
208                                 // larger ranges of those.
209                                 pcd_pause_len &gt;= 10;
210                                 pcd_pause_len &lt;= 50;
211                     
212                                 // Pause Detector Requirements
213                                 pause_n_asserts_after_ps &gt;= 0;
214                                 pause_n_asserts_after_ps &lt; (pcd_pause_len*CLOCK_PERIOD_PS);
215                                 pause_n_deasserts_after_ps &gt;= 0;
216                                 pause_n_deasserts_after_ps &lt; 300*1000;  // 300ns
217                     
218                                 // Clock recovery requirements
219                                 clock_stops_after_ps &gt;= 0;
220                                 clock_stops_after_ps &lt; (pcd_pause_len*CLOCK_PERIOD_PS);
221                                 clock_starts_after_ps &gt;= 0;
222                                 clock_starts_after_ps &lt; pause_n_deasserts_after_ps;
223                     
224                                 // there's some simulation errors where we get the wrong number of ticks
225                                 // if the clock/pause starts/stops exactly on an edge. So make sure that doesn't happen
226                                 (clock_stops_after_ps*2 % CLOCK_PERIOD_PS) != 0;
227                                 (clock_starts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
228                                 (pause_n_asserts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
229                                 (pause_n_deasserts_after_ps*2 % CLOCK_PERIOD_PS) != 0;
230                             };
231                     
232                             /* $display(&quot;\nUsing:&quot;);
233                             $display(&quot;  PCD pause length     %d ticks&quot;, pcd_pause_len);
234                             $display(&quot;  pause_n_asserts_after   %d ps&quot;, pause_n_asserts_after_ps);
235                             $display(&quot;  pause_n_deasserts_after %d ps&quot;, pause_n_deasserts_after_ps);
236                             $display(&quot;  clock_stops_after       %d ps&quot;, clock_stops_after_ps);
237                             $display(&quot;  clock_starts_after      %d ps&quot;, clock_starts_after_ps);
238                             $display(&quot;========================================&quot;); */
239                     
240        1/1                  analogue_sim_inst.set_pause_ticks(pcd_pause_len);
241        1/1                  analogue_sim_inst.set_params(.clock_stops                   (1'b1),
242                                                          .clock_stops_after_ps          (clock_stops_after_ps),
243                                                          .clock_starts_after_ps         (clock_starts_after_ps),
244                                                          .pause_n_asserts_after_ps      (pause_n_asserts_after_ps),
245                                                          .pause_n_deasserts_after_ps    (pause_n_deasserts_after_ps));
246                         endfunction
247                     
248                     
249                         initial begin
250        1/1                  send_queue = '{};
251        1/1                  analogue_sim_inst.init();
252        1/1                  analogue_sim_inst.start(send_queue);
253                     
254                             // reset for 5 ticks
255        1/1                  rst_n &lt;= 1'b0;
256        2/2                  repeat (5) @(posedge clk) begin end
                        REPEAT_FALSE
257        1/1                  rst_n &lt;= 1'b1;
258        2/2                  repeat (5) @(posedge clk) begin end
                        REPEAT_FALSE
259                     
260                             // Test with the default values for the AFE
261                             // run two tests because the clock may start again with a falling edge or a rising edge
262        1/1                  $display(&quot;Testing with the default AFE values&quot;);
263        1/1                  min_time_between_deasserts = 64'd1000000000;
264        1/1                  max_time_between_deasserts = 64'd0;
265        1/1                  repeat(10000) begin
266        1/1                      send_data;
267                             end
                        REPEAT_FALSE
268                     
269        1/1                  $display(&quot;Time between pause_n_async deasserting and pause_n_synchronised deasserting:&quot;);
270        1/1                  $display(&quot;  min: %d&quot;, min_time_between_deasserts);
271        1/1                  $display(&quot;  max: %d&quot;, max_time_between_deasserts);
272        1/1                  $display(&quot;&quot;);
273                     
274                             // test with the clock stopping (expected behaviour)
275        1/1                  $display(&quot;Testing with actual AFE requirements&quot;);
276        1/1                  min_time_between_deasserts = 64'd1000000000;
277        1/1                  max_time_between_deasserts = 64'd0;
278        1/1                  repeat (10000) begin
279        1/1                      randomise_params_afe;
280        1/1                      send_data;
281                             end
                        REPEAT_FALSE
282                     
283        1/1                  $display(&quot;Time between pause_n_async deasserting and pause_n_synchronised deasserting:&quot;);
284        1/1                  $display(&quot;  min: %d&quot;, min_time_between_deasserts);
285        1/1                  $display(&quot;  max: %d&quot;, max_time_between_deasserts);
286        1/1                  $display(&quot;&quot;);
287                     
288        1/1                  $display(&quot;Testing with the clock stopping&quot;);
289        1/1                  min_time_between_deasserts = 64'd1000000000;
290        1/1                  max_time_between_deasserts = 64'd0;
291        1/1                  repeat (10000) begin
292        1/1                      randomise_params(1'b1);
293        1/1                      send_data;
294                             end
                        REPEAT_FALSE
295                     
296        1/1                  $display(&quot;Time between pause_n_async deasserting and pause_n_synchronised deasserting:&quot;);
297        1/1                  $display(&quot;  min: %d&quot;, min_time_between_deasserts);
298        1/1                  $display(&quot;  max: %d&quot;, max_time_between_deasserts);
299        1/1                  $display(&quot;&quot;);
300                     
301                             // test with the clock not stopping.
302        1/1                  $display(&quot;Testing with the clock not stopping&quot;);
303        1/1                  min_time_between_deasserts = 64'd1000000000;
304        1/1                  max_time_between_deasserts = 64'd0;
305        1/1                  repeat (10000) begin
306        1/1                      randomise_params(1'b0);
307        1/1                      send_data;
308                             end
                        REPEAT_FALSE
309                     
310        1/1                  $display(&quot;Time between pause_n_async deasserting and pause_n_synchronised deasserting:&quot;);
311        1/1                  $display(&quot;  min: %d&quot;, min_time_between_deasserts);
312        1/1                  $display(&quot;  max: %d&quot;, max_time_between_deasserts);
313        1/1                  $display(&quot;&quot;);
314                     
315        2/2                  repeat (5) @(posedge clk) begin end
                        REPEAT_FALSE
316                     
317                             // assert reset for toggle coverage
318        1/1                  rst_n &lt;= 1'b0;
319        2/2                  repeat (5) @(posedge clk) begin end
                        REPEAT_FALSE
320        1/1                  $stop;
</pre>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod6.html" >pause_n_latch_and_synchroniser_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s10">
<td>Totals</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Total Bits</td>
<td class="rt">10</td>
<td class="rt">10</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Total Bits 0->1</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Total Bits 1->0</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s10">
<td>Signals</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>Signal Bits</td>
<td class="rt">10</td>
<td class="rt">10</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>pause_n_async</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>pause_n_synchronised</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod6.html" >pause_n_latch_and_synchroniser_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s10">
<td>Branches</td>
<td></td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">80</td>
<td class="rt">5</td>
<td class="rt">5</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
80                 if (!rst_n) begin
                   <font color = "green">-1-</font>  
           <font color = "green">        ==></font>
81                     // this deassert is because we're in reset
82                     // ignore it
83                 end
84                 else begin
85                     if (deassert_delay < min_time_between_deasserts) begin
                       <font color = "green">-2-</font>  
86                         min_time_between_deasserts <= deassert_delay;
           <font color = "green">                ==></font>
87                     end
                       MISSING_ELSE
           <font color = "green">            ==></font>
88                     if (deassert_delay > max_time_between_deasserts) begin
                       <font color = "green">-3-</font>  
89                         max_time_between_deasserts <= deassert_delay;
           <font color = "green">                ==></font>
90                     end
                       MISSING_ELSE
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<hr>
<a name="Assert"></a>
Assert Coverage for Module : <a href="mod6.html" >pause_n_latch_and_synchroniser_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Attempted</th><th nowrap width=80>Percent</th><th nowrap width=80>Succeeded/Matched</th><th nowrap width=80>Percent</th></tr><tr>
<td class="wht cl"><a href="#1395033126" >Assertions</a></td>
<td class="wht cl rt">3</td>
<td class="s10 cl rt">3</td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">3</td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl"><a href="#1918456527" >Cover properties</a></td>
<td class="wht cl rt">0</td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
</tr><tr>
<td class="wht cl"><a href="#992442900" >Cover sequences</a></td>
<td class="wht cl rt">0</td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
</tr><tr>
<td class="wht cl"><b>Total</b></td>
<td class="wht cl rt">3</td>
<td class="s10 cl rt">3</td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">3</td>
<td class="s10 cl rt">100.00</td>
</tr></table><br clear=all>
<br clear=all>
<hr>
<br clear=all>
<a name="1395033126"></a>
<b>Assertion Details</b><br clear=all>
<br clear=all>
<table align=left class="sortable noborder">
<tr class="sortablehead">
<td class="alfsrt">Name</td><td>Attempts</td><td>Real Successes</td><td>Failures</td><td>Incomplete</td></tr><tr>
<td class="wht cl"><a name="1150433379"></a>
assert_delay</td>
<td class="s9 cl rt">14634787</td>
<td class="s9 cl rt">33532</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1984231164"></a>
deassert_delay</td>
<td class="s9 cl rt">14634787</td>
<td class="s9 cl rt">33532</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1543382354"></a>
in_reset</td>
<td class="s9 cl rt">14634787</td>
<td class="s9 cl rt">9</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_7">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
    <li>
      <a href="#Assert">Assert</a>    </li>
  </ul>
  <ul name="tag_pause_n_latch_and_synchroniser_tb">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
    <li>
      <a href="#Assert">Assert</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
