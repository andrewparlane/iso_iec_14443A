<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: iso14443_3a_tb</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_iso14443_3a_tb'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_iso14443_3a_tb')">iso14443_3a_tb</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s9 cl rt"> 99.70</td>
<td class="s10 cl rt"><a href="mod31.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod31.html#Toggle" > 98.82</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod31.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod31.html#Assert" >100.00</a></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/home/aparlane/fiuba_thesis/hdl/components/iso_iec_14443A/verification/vcs/../../verification/tb/iso14443_3a/iso14443_3a_tb.sv')">/home/aparlane/fiuba_thesis/hdl/components/iso_iec_14443A/verification/vcs/../../verification/tb/iso14443_3a/iso14443_3a_tb.sv</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod31.html#inst_tag_40"  onclick="showContent('inst_tag_40')">iso14443_3a_tb</a></td>
<td class="s9 cl rt"> 99.70</td>
<td class="s10 cl rt"><a href="mod31.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod31.html#Toggle" > 98.82</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod31.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod31.html#Assert" >100.00</a></td>
</tr></table></div>
</div>
<br clear=all>
<div name='tag_iso14443_3a_tb'>
<hr>
<a name="inst_tag_40"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_40" >iso14443_3a_tb</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s9 cl rt"> 99.70</td>
<td class="s10 cl rt"><a href="mod31.html#Line" >100.00</a></td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"><a href="mod31.html#Toggle" > 98.82</a></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt"><a href="mod31.html#Branch" >100.00</a></td>
<td class="s10 cl rt"><a href="mod31.html#Assert" >100.00</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s9 cl rt"> 92.23</td>
<td class="s9 cl rt"> 90.08</td>
<td class="s9 cl rt"> 92.16</td>
<td class="s9 cl rt"> 94.87</td>
<td class="s8 cl rt"> 80.00</td>
<td class="s9 cl rt"> 96.30</td>
<td class="s10 cl rt">100.00</td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<span class=inst>none</span>
<br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod37.html#inst_tag_46" id="tag_urg_inst_46">clock_source_inst</a></td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod29.html#inst_tag_38" id="tag_urg_inst_38">dut</a></td>
<td class="s9 cl rt"> 92.42</td>
<td class="s9 cl rt"> 91.21</td>
<td class="s9 cl rt"> 92.16</td>
<td class="s9 cl rt"> 94.94</td>
<td class="s8 cl rt"> 80.00</td>
<td class="s9 cl rt"> 96.21</td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod2.html#inst_tag_2" id="tag_urg_inst_2">rx_iface_from_14443_2a</a></td>
<td class="s7 cl rt"> 79.86</td>
<td class="s6 cl rt"> 69.57</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 70.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod2.html#inst_tag_3" id="tag_urg_inst_3">rx_iface_to_14443_4a</a></td>
<td class="s8 cl rt"> 89.86</td>
<td class="s6 cl rt"> 69.57</td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_11" id="tag_urg_inst_11">tx_iface_from_14443_4a</a></td>
<td class="s8 cl rt"> 87.50</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_10" id="tag_urg_inst_10">tx_iface_to_14443_2a</a></td>
<td class="s8 cl rt"> 83.33</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s10 cl rt">100.00</td>
</tr></table><br clear=all>
</div>
</div>
<hr>
Since this is the module's only instance, the coverage report is the same as for the module.</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_iso14443_3a_tb'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod31.html" >iso14443_3a_tb</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s10"><td class="lf">TOTAL</td><td></td><td>47</td><td>47</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>207</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>213</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>225</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>579</td><td>39</td><td>39</td><td>100.00</td></tr>
</table>
<pre class="code"><br clear=all>
206                         longint lastPauseRise;
207        1/1              always_ff @(posedge pause_n_synchronised) lastPauseRise &lt;= $time;
208                     
209                         logic last_rx_bit;
210                         assign last_rx_bit = dut.framing_inst.last_rx_bit;
211                         always_ff @(posedge tx_iface_to_14443_2a.data_valid) begin: triggerBlock
212                             // tx has started
213        1/1                  automatic longint diff = $time - lastPauseRise;
214        1/1                  automatic longint expected = CLOCK_PERIOD_PS * (last_rx_bit ? FDT_LAST_BIT_1 : FDT_LAST_BIT_0);
215                             //$display(&quot;Tx started at %d ps, lastPauseRise %d ps, diff %d ps (%d ticks), expected %d ps (%d ticks)&quot;,
216                             //         $time, lastPauseRise, diff, int'(diff / CLOCK_PERIOD_PS), expected, int'(expected / CLOCK_PERIOD_PS));
217                     
218                             fdtTime: assert (diff == expected)
219                                 else $error(&quot;Tx started at %d ps, lastPauseRise %d ps, diff %d, expected %d&quot;,
220                                             $time, lastPauseRise, diff, expected);
221                         end
222                     
223                         // trigger the pause_n_synchronised signal on the rx_iface_from_14443_2a.eoc signal
224                         always_ff @(posedge clk, negedge rst_n) begin
225        1/1                  if (!rst_n) begin
226        1/1                      pause_n_synchronised &lt;= 1'b1;
227                             end
228                             else begin
229                                 // only pulse for one tick
230        1/1                      pause_n_synchronised &lt;= 1'b1;
231                     
232        1/1                      if (rx_iface_from_14443_2a.eoc) begin
233        1/1                          pause_n_synchronised &lt;= 1'b0;
234                                 end
                        MISSING_ELSE
235                             end
236                         end
237                     
238                         // ----------------------------------------------------------------
239                         // Extend CommsTestsSequence to do TB specific stuff
240                         // ----------------------------------------------------------------
241                     
242                         class ISO14443_3aTbSequence
243                         extends comms_tests_sequence_pkg::CommsTestsSequence
244                         #(
245                             .RxTransType        (RxInTransType),
246                             .TxTransType        (TxOutTransType),
247                             .RxTransConvType    (RxTransConvType),
248                             .TxTransConvType    (TxTransConvType),
249                             .RxDriverType       (RxDriverType),
250                             .TxMonitorType      (TxMonitorType)
251                         );
252                     
253                             // should we be checking rx_crc_ok?
254                             logic           corrupt_crcs;
255                     
256                             // when the initialisation module is in State_ACTIVE[_STAR] or State_PROTOCOL
257                             // messages are routed to both the initialisation module and the part4 module
258                             // we want to validate that the messages arrive correctly. We don't check every
259                             // message, because I don't have an easy way to know exactly what is sent
260                             // but in some cases such as RATS and S(DESELECT) I'm already overriding the
261                             // send_X_verify_relpy() tasks, so I can generate the expected message there.
262                             logic           check_rx_to_14443_4a;
263                             RxOutTransType  expected_rx_to_14443_4a;
264                     
265                             // Transaction generators for app level messages
266                             TransGenType    app_rx_trans_gen;
267                     
268                             // constructor
269                             function new(uid_pkg::UID               _picc_uid,
270                                          TransGenType               _rx_trans_gen,
271                                          TransGenType               _tx_trans_gen,
272                                          RxTransConvType            _rx_conv_gen,
273                                          TxTransConvType            _tx_conv_gen,
274                                          RxQueueWrapperType         _rx_send_queue,
275                                          TxQueueWrapperType         _tx_recv_queue,
276                                          RxDriverType               _rx_driver,
277                                          TxMonitorType              _tx_monitor,
278                                          int                        _reply_timeout);
279                                 super.new(_picc_uid,
280                                           _rx_trans_gen,
281                                           _tx_trans_gen,
282                                           _rx_conv_gen,
283                                           _tx_conv_gen,
284                                           _rx_send_queue,
285                                           _tx_recv_queue,
286                                           _rx_driver,
287                                           _tx_monitor,
288                                           _reply_timeout,
289                                           100);             // TODO: Run optimised builds and test with more than 100 loops per test
290                     
291                                 corrupt_crcs            = 1'b0;
292                                 check_rx_to_14443_4a    = 1'b0;
293                     
294                                 // the messages will contain the CRC at this point
295                                 app_rx_trans_gen        = new(1'b1);
296                             endfunction
297                     
298                             virtual task do_reset;
299                                 rst_n &lt;= 1'b0;
300                                 repeat (5) @(posedge clk) begin end
301                                 rst_n &lt;= 1'b1;
302                                 repeat (5) @(posedge clk) begin end
303                             endtask
304                     
305                             function void sequence_callback(EventCode ec, int arg=0);
306                                 case (ec)
307                                     EventCode_SENDING:  begin
308                                         // argument is an EventMessageID
309                                         automatic EventMessageID mid = EventMessageID'(arg);
310                     
311                                         //$display(&quot;Sending %s&quot;, mid.name);
312                     
313                                         //$display(&quot;message: %s&quot;, mid.name);
314                                         if (mid == EventMessageID_RATS) begin
315                                             // Fake the RATS signal from the part4 module
316                                             // only valid if the CRC is not corrupt
317                                             iso14443_4a_rats = !corrupt_crcs;
318                                         end
319                                     end
320                                     EventCode_SENT: begin: ecSent
321                                         // argument is an EventMessageID
322                                         automatic EventMessageID    mid                 = EventMessageID'(arg);
323                                         automatic logic             check_crc           = 1'b0;
324                                         automatic logic             expect_forwarded;
325                     
326                                         //$display(&quot;Sent %s&quot;, mid.name);
327                                         // clear RATS if it were set
328                                         iso14443_4a_rats = 1'b0;
329                     
330                                         // verify that the rx_crc_ok signal is asserted if this was a message
331                                         // that should have a CRC
332                                         if (!corrupt_crcs &amp;&amp; !rx_driver.get_add_error) begin
333                                             case(mid)
334                                                 EventMessageID_REQA:                    begin end
335                                                 EventMessageID_WUPA:                    begin end
336                                                 EventMessageID_HLTA:                    check_crc = 1'b1;
337                                                 EventMessageID_AC:                      begin end
338                                                 EventMessageID_SELECT:                  check_crc = 1'b1;
339                                                 EventMessageID_RATS:                    check_crc = 1'b1;
340                                                 EventMessageID_PPS:                     check_crc = 1'b1;
341                                                 EventMessageID_STD_S_DESELECT:          check_crc = 1'b1;
342                                                 EventMessageID_STD_I_BLOCK_CHAINING:    check_crc = 1'b1;
343                                                 EventMessageID_STD_I_BLOCK_NO_CHAINING: check_crc = 1'b1;
344                                                 EventMessageID_STD_R_ACK:               check_crc = 1'b1;
345                                                 EventMessageID_STD_R_NAK:               check_crc = 1'b1;
346                                                 EventMessageID_STD_S_DESELECT:          check_crc = 1'b1;
347                                                 EventMessageID_STD_S_PARAMETERS:        check_crc = 1'b1;
348                                                 EventMessageID_RANDOM_NON_VALID:        check_crc = 1'b1;
349                                                 default: begin
350                                                     $error(&quot;Handle mid: %s&quot;, mid.name);
351                                                 end
352                                             endcase
353                                         end
354                     
355                                         if (check_crc) begin: checkCRC
356                                             crcOK: assert (rx_crc_ok) else $error(&quot;rx_crc_ok = 0 when expecting 1&quot;);
357                                         end
358                     
359                                         // Depending on the state of the initialisation module, this message
360                                         // could be received the rx_monitor on the rx_iface_to_14443_4a interface.
361                                         // check that it has been received or not as expected.
362                                         // we don't actually check the message contents here, since we have no way
363                                         // of knowing what has been sent. The message contents are checked later in
364                                         // a specific test.
365                                         // NOTE: We assume it will have been already received by the monitor
366                                         //       due to the rx driver's ticks_after_transaction delay.
367                                         //       that should be set high enough to ensure any message is received
368                                         //       by the time we get here.
369                     
370                                         expect_forwarded = (picc_state == State_ACTIVE)                 ||
371                                                            (picc_state == State_ACTIVE_STAR)            ||
372                                                            (picc_state == State_PROTOCOL_PPS_ALLOWED)   ||
373                                                            (picc_state == State_PROTOCOL_STD_COMMS);
374                     
375                                         forwardedAsExpected:
376                                             assert (rx_recv_queue.size() == (expect_forwarded ? 1 : 0))
377                                             else $error(&quot;%d replies in the rx_recv_queue, expected %d&quot;,
378                                                          rx_recv_queue.size,
379                                                          (expect_forwarded ? 1 : 0));
380                     
381                                         // pop off any reply
382                                         if (rx_recv_queue.size() != 0) begin: forwadedTo14443_4a
383                                             automatic RxOutTransType    recv_trans  = rx_recv_queue.pop_front;
384                                             if (check_rx_to_14443_4a) begin: checkForwardedPkt
385                                                 automatic logic res = recv_trans.compare(expected_rx_to_14443_4a);
386                                                 iso144434aAsExpected:
387                                                     assert (res)
388                                                     else $error(&quot;Packet forwarded to rx_iface_to_14443_4a not as expected, received %s expected %s&quot;,
389                                                                 recv_trans.to_string, expected_rx_to_14443_4a.to_string);
390                                             end
391                                         end
392                                     end
393                                     EventCode_RECEIVED_OK: begin
394                                         // nothing to do here
395                                     end
396                                     EventCode_RECEIVED_ERROR: begin
397                                         // nothing to do here
398                                     end
399                                     default: begin
400                                         $error(&quot;Handle event: %s&quot;, ec.name);
401                                     end
402                                 endcase
403                             endfunction
404                     
405                             function void specific_target_callback(SpecificTargetEventCode ec, int arg=0);
406                                 if ((ec == SpecificTargetEventCode_ENTERED_STATE) ||
407                                     (ec == SpecificTargetEventCode_REMAINING_IN_STATE)) begin
408                                     automatic State state = State'(arg);
409                                     //$display(&quot;Event Code %s, %s&quot;, ec.name, state.name);
410                                     check_state(state);
411                                 end
412                                 else begin
413                                     $error(&quot;Unknown event code %s&quot;, ec.name);
414                                 end
415                             endfunction
416                     
417                             function void comms_tests_callback(CommsTestsEventCode ec, int arg=0);
418                                 case (ec)
419                                     CommsTestsEventCode_SET_CORRUPT_CRC: begin
420                                         // since we indicate CRCs are OK with rx_crc_ok we need to note not to do that
421                                         // when we are sending corrupt CRCs
422                                         corrupt_crcs = arg;
423                                     end
424                                     CommsTestsEventCode_SET_DRIVER_ERRORS: begin
425                                     end
426                                     default: begin
427                                         $error(&quot;Unknown event code %s&quot;, ec.name);
428                                     end
429                                 endcase
430                             endfunction
431                     
432                             function void check_state (State state);
433                                 case (state)
434                                     State_IDLE:                 isIdle:         assert ((initState == ISO14443A_pkg::InitialisationState_IDLE)      &amp;&amp; !dut.initialisation_inst.state_star) else $error(&quot;DUT not in correct state expected State_IDLE, 0 got %s, %b&quot;,               initState.name, dut.initialisation_inst.state_star);
435                                     State_READY:                isReady:        assert ((initState == ISO14443A_pkg::InitialisationState_READY)     &amp;&amp; !dut.initialisation_inst.state_star) else $error(&quot;DUT not in correct state expected State_READY, 0 got %s, %b&quot;,              initState.name, dut.initialisation_inst.state_star);
436                                     State_ACTIVE:               isActive:       assert ((initState == ISO14443A_pkg::InitialisationState_ACTIVE)    &amp;&amp; !dut.initialisation_inst.state_star) else $error(&quot;DUT not in correct state expected State_ACTIVE, 0 got %s, %b&quot;,             initState.name, dut.initialisation_inst.state_star);
437                                     State_HALT:                 isHalt:         assert ((initState == ISO14443A_pkg::InitialisationState_IDLE)      &amp;&amp; dut.initialisation_inst.state_star)  else $error(&quot;DUT not in correct state expected State_IDLE, 1 got %s, %b&quot;,               initState.name, dut.initialisation_inst.state_star);
438                                     State_READY_STAR:           isReadyStar:    assert ((initState == ISO14443A_pkg::InitialisationState_READY)     &amp;&amp; dut.initialisation_inst.state_star)  else $error(&quot;DUT not in correct state expected State_READY, 1 got %s, %b&quot;,              initState.name, dut.initialisation_inst.state_star);
439                                     State_ACTIVE_STAR:          isActiveStar:   assert ((initState == ISO14443A_pkg::InitialisationState_ACTIVE)    &amp;&amp; dut.initialisation_inst.state_star)  else $error(&quot;DUT not in correct state expected State_ACTIVE, 1 got %s, %b&quot;,             initState.name, dut.initialisation_inst.state_star);
440                                     State_PROTOCOL_PPS_ALLOWED: isProtocol1:    assert ((initState == ISO14443A_pkg::InitialisationState_PROTOCOL))                                         else $error(&quot;DUT not in correct state expected State_PROTOCOL_PPS_ALLOWED, got %s, %b&quot;, initState.name, dut.initialisation_inst.state_star);
441                                     State_PROTOCOL_STD_COMMS:   isProtocol2:    assert ((initState == ISO14443A_pkg::InitialisationState_PROTOCOL))                                         else $error(&quot;DUT not in correct state expected State_PROTOCOL_STD_COMMS, got %s, %b&quot;,   initState.name, dut.initialisation_inst.state_star);
442                                 endcase
443                             endfunction
444                     
445                             // override send_rats_verify_reply as the DUT does not respond to the RATS message
446                             // we want to send it still as the DUT needs to receive a packet and see the iso14443_4a_rats
447                             // signal asserting to transiction into State_PROTOCOL.
448                             task send_rats_verify_reply(logic [3:0] fsdi, logic [3:0] cid);
449                                 // sending RATS, validate it on arrival on the rx_iface_to_14443_4a
450                                 // note: this check only occurs if a packet is expected on that interface
451                                 //       and one has actually been received
452                                 check_rx_to_14443_4a    = 1'b1;
453                                 expected_rx_to_14443_4a = RxOutTransType::create_from_rx_byte_transaction(app_rx_trans_gen.generate_rats(fsdi, cid));
454                     
455                                 send_rats(fsdi, cid);
456                                 verify_no_reply;
457                     
458                                 check_rx_to_14443_4a    = 1'b0;
459                             endtask
460                     
461                             // override send_pps_verify_reply as the DUT does not respond to the PPS message
462                             // we still send it so we can verify it is routed correctly to the part4 block
463                             virtual task send_pps_verify_reply(logic p1_present, logic [1:0] dsi, logic [1:0] dri);
464                                 automatic logic [3:0] cid = picc_target.get_cid();
465                                 // sending PPS, validate it on arrival on the rx_iface_to_14443_4a
466                                 // note: this check only occurs if a packet is expected on that interface
467                                 //       and one has actually been received
468                                 check_rx_to_14443_4a    = 1'b1;
469                                 expected_rx_to_14443_4a = RxOutTransType::create_from_rx_byte_transaction(app_rx_trans_gen.generate_pps(cid, p1_present, dsi, dri));
470                     
471                                 send_pps(cid, p1_present, dsi, dri);
472                                 verify_no_reply;
473                     
474                                 check_rx_to_14443_4a    = 1'b0;
475                             endtask
476                     
477                             // override send_std_s_deselect_verify_reply as the DUT does not respond to the
478                             // S(DESELECT) message we still send it, and verify that the DUT doesn't reply
479                             // then we pulse the iso14443_4a_deselect signal. This is how it would work in
480                             // the full design.
481                             virtual task send_std_s_deselect_verify_reply(std_block_address_pkg::StdBlockAddress addr);
482                                 // sending RATS, validate it on arrival on the rx_iface_to_14443_4a
483                                 // note: this check only occurs if a packet is expected on that interface
484                                 //       and one has actually been received
485                                 check_rx_to_14443_4a    = 1'b1;
486                                 expected_rx_to_14443_4a = RxOutTransType::create_from_rx_byte_transaction(app_rx_trans_gen.generate_std_s_deselect_for_rx(addr));
487                     
488                                 send_std_s_deselect(addr);
489                                 verify_no_reply;
490                     
491                                 iso14443_4a_deselect    &lt;= 1'b1;
492                                 @(posedge clk) begin end
493                                 iso14443_4a_deselect    &lt;= 1'b0;
494                                 @(posedge clk) begin end
495                     
496                                 // since the state change happens after the reply has been sent out
497                                 // we can't check for it during the send_std_s_deselect task as normal
498                                 // so we do it in the wait_for_and_verify_std_s_deselect() task.
499                                 // Except we don't call that here, so we need to manually register the state change
500                                 register_state_change(State_HALT);
501                     
502                                 check_rx_to_14443_4a    = 1'b0;
503                             endtask
504                     
505                             // override this to add an extra test
506                             virtual task run_all_initialisation_tests;
507                                 super.run_all_initialisation_tests;
508                                 run_part4_tx_routing_tests;
509                             endtask
510                     
511                             task run_part4_tx_routing_tests;
512                                 // Test that when in State_PROTOCOL_* messages transmitted on the
513                                 // tx_iface_from_14443_4a is routed to the tx_iface_to_14443_2a
514                                 // with CRC and parity bits added
515                     
516                                 $display(&quot;State_PROTOCOL_* + routing from the iso14443-4a block&quot;);
517                                 repeat (num_loops_per_test) begin
518                                     // keep the length low, as the framing module will add 2 bytes of CRC
519                                     // and we want out reply_timeout to be as low as possible since
520                                     // that is directly related to simulation speed.
521                                     automatic TxInTransType tx_send_trans   = TxInTransType::new_random_transaction($urandom_range(1,3), 0);
522                                     automatic TxInTransType tx_expected     = new(tx_send_trans.data, tx_send_trans.bits_in_first_byte);
523                     
524                                     go_to_state(1'($urandom) ? State_PROTOCOL_PPS_ALLOWED : State_PROTOCOL_STD_COMMS);
525                     
526                                     // set whether we add a CRC or not to the Tx message
527                                     tx_append_crc_14443_4a = 1'($urandom);
528                     
529                                     // The FDT won't fire unless we send an Rx packet first
530                                     send_random_non_valid;
531                     
532                                     // fake a transmit from the part4 block
533                                     tx_send_queue.push_back(tx_send_trans);
534                     
535                                     // add the CRC if needed
536                                     if (tx_append_crc_14443_4a) begin
537                                         tx_expected.append_crc;
538                                     end
539                     
540                                     wait_for_and_verify_trans(tx_expected, int'(EventMessageID_RANDOM_NON_VALID), &quot;APP Tx&quot;);
541                     
542                                     // confirm our state hasn't changed
543                                     register_no_state_change;
544                     
545                                     // re-enable auto adding CRCs in the tx_trans_gen
546                                     tx_trans_gen.set_auto_append_crc(1'b1);
547                                 end
548                             endtask
549                     
550                             // not used in this test
551                             virtual function logic verify_dut_cid(logic [3:0] expected);
552                                 return 1'b1;
553                             endfunction
554                     
555                             // not used in this test
556                             virtual function ByteQueue get_std_i_reply_inf(logic [7:0] inf [$]);
557                                 return '{};
558                             endfunction
559                     
560                             // not used in this test
561                             virtual protected function void set_power_input(logic [1:0] _power);
562                             endfunction
563                     
564                         endclass
565                     
566                         ISO14443_3aTbSequence seq;
567                     
568                         // --------------------------------------------------------------
569                         // Test stimulus
570                         // --------------------------------------------------------------
571                     
572                         initial begin
573                             automatic transaction_generator_pkg::TransactionGenerator   rx_trans_gen;
574                             automatic transaction_generator_pkg::TransactionGenerator   tx_trans_gen;
575                             automatic RxTransConvType                                   rx_trans_conv;
576                             automatic TxTransConvType                                   tx_trans_conv;
577                             automatic int                                               reply_timeout;
578                     
579        1/1                  tx_append_crc_14443_4a  = 1'b0;
580        1/1                  iso14443_4a_deselect    = 1'b0;
581        1/1                  iso14443_4a_rats        = 1'b0;
582                     
583        1/1                  rx_driver           = new(rx_iface_from_14443_2a);
584        1/1                  rx_monitor          = new(rx_iface_to_14443_4a);
585        1/1                  tx_monitor          = new(tx_iface_to_14443_2a);
586        1/1                  tx_driver           = new(tx_iface_from_14443_4a, 0, 256, 512);  // each byte is 8 bits + parity, sink driver sends req every 16 ticks
587        1/1                  tx_sink_driver      = new(tx_iface_to_14443_2a);
588                     
589        1/1                  rx_send_queue       = new('{});
590        1/1                  tx_recv_queue       = new('{});
591                             // tx_send_queue and rx_recv_queue are just queues and don't use the wrapper class
592        1/1                  rx_recv_queue       = '{};
593        1/1                  tx_send_queue       = '{};
594                     
595        1/1                  rx_trans_gen        = new(1'b1);    // Rx messages must have CRCs applied
596        1/1                  tx_trans_gen        = new(1'b1);    // Tx messages will have CRCs applied
597                     
598        1/1                  rx_trans_conv       = new(1'b1);    // Rx messages must have parity bits
599        1/1                  tx_trans_conv       = new(1'b1);    // Tx messages will have parity bits
600                     
601                             // initialise the variable part of the UID to be all ones.
602                             // this is so on the first test when we swap to all 0s, we get the 1-&gt;0 toggle coverage
603                             // we then switch back to 1 to get 0-&gt;1.
604        1/1                  picc_uid        = new('1);
605        1/1                  full_uid = picc_uid.get_uid;
606                     
607                             // longest reply is 5 bytes, sink_driver uses 16 ticks between reqs
608                             // each byte has 8 bits + parity -&gt; 45 bits -&gt; 720 ticks.
609                             // then the FDT takes ~130 ticks to fire (in the worst case)
610        1/1                  reply_timeout   = 1024;
611        1/1                  seq             = new(picc_uid,
612                                                   rx_trans_gen,
613                                                   tx_trans_gen,
614                                                   rx_trans_conv,
615                                                   tx_trans_conv,
616                                                   rx_send_queue,
617                                                   tx_recv_queue,
618                                                   rx_driver,
619                                                   tx_monitor,
620                                                   reply_timeout);
621                     
622        1/1                  rx_driver.start         (rx_send_queue.data);
623        1/1                  rx_monitor.start        (rx_recv_queue);
624        1/1                  tx_monitor.start        (tx_recv_queue.data);
625        1/1                  tx_driver.start         (tx_send_queue);
626        1/1                  tx_sink_driver.start    ();
627                     
628        1/1                  seq.do_reset;
629                     
630                             // Routing is tested as follows:
631                             //  Rx 14443_2a -&gt; init     - tested by checking state transitions and replies
632                             //  Rx 14443_2a -&gt; 14443_4a - tested by verifying RATS, PPS and S(DESELECT) are received OK
633                             //  Tx init     -&gt; 14443_2a - tested by checking replies
634                             //  Tx 14443_4a -&gt; 14443_2a - tested in run_part4_tx_routing_tests()
635                     
636                             // repeat 10 times with different UIDs
637        1/1                  for (int i = 0; i &lt; 10; i++) begin
638                                 // TODO: Add a parameter to let me instead test all possible variable_uid values
639                                 //       For when running initialisation_tb_actual with UID_INPUT_BITS being small
640                     
641        1/1                      if (i == 0) begin
642                                     // set the variable part of the uid to 0
643                                     // this and the i == 1 case help us get toggle coverage
644        1/1                          picc_uid.set_uid('0);
645                                 end
646        1/1                      else if (i == 1) begin
647                                     // set the variable part of the uid to all ones
648        1/1                          picc_uid.set_uid('1);
649                                 end
650                                 else begin
651                                     // randomise the variable part of the UID
652        1/1                          picc_uid.randomize;
653                                 end
654                     
655        1/1                      full_uid = picc_uid.get_uid;
656        1/1                      $display(&quot;NOTE: New UID: %s&quot;, picc_uid.to_string);
657        1/1                      seq.do_reset;
658                     
659                                 // Run the tests
660        1/1                      seq.run_all_initialisation_tests();
661                             end
662                     
663        2/2                  repeat (5) @(posedge clk) begin end
                        REPEAT_FALSE
664        1/1                  $stop;
</pre>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod31.html" >iso14443_3a_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s9">
<td>Totals</td>
<td class="rt">12</td>
<td class="rt">11</td>
<td class="rt">91.67 </td>
</tr><tr class="s9">
<td>Total Bits</td>
<td class="rt">338</td>
<td class="rt">334</td>
<td class="rt">98.82 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 0->1</td>
<td class="rt">169</td>
<td class="rt">167</td>
<td class="rt">98.82 </td>
</tr><tr class="s9">
<td nowrap>Total Bits 1->0</td>
<td class="rt">169</td>
<td class="rt">167</td>
<td class="rt">98.82 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s9">
<td>Signals</td>
<td class="rt">12</td>
<td class="rt">11</td>
<td class="rt">91.67 </td>
</tr><tr class="s9">
<td>Signal Bits</td>
<td class="rt">338</td>
<td class="rt">334</td>
<td class="rt">98.82 </td>
</tr><tr class="s9">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">169</td>
<td class="rt">167</td>
<td class="rt">98.82 </td>
</tr><tr class="s9">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">169</td>
<td class="rt">167</td>
<td class="rt">98.82 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_n</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>uid_variable[77:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>pause_n_synchronised</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rx_crc_ok</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>tx_append_crc_14443_4a</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>iso14443_4a_deselect</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>iso14443_4a_rats</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>iso14443_4a_tag_active</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>initState[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>full_uid[77:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>full_uid[79:78]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>last_rx_bit</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod31.html" >iso14443_3a_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s10">
<td>Branches</td>
<td></td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">225</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
225                if (!rst_n) begin
                   <font color = "green">-1-</font>  
226                    pause_n_synchronised <= 1'b1;
           <font color = "green">            ==></font>
227                end
228                else begin
229                    // only pulse for one tick
230                    pause_n_synchronised <= 1'b1;
231        
232                    if (rx_iface_from_14443_2a.eoc) begin
                       <font color = "green">-2-</font>       
233                        pause_n_synchronised <= 1'b0;
           <font color = "green">                ==></font>
234                    end
                       MISSING_ELSE
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<hr>
<a name="Assert"></a>
Assert Coverage for Module : <a href="mod31.html" >iso14443_3a_tb</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Attempted</th><th nowrap width=80>Percent</th><th nowrap width=80>Succeeded/Matched</th><th nowrap width=80>Percent</th></tr><tr>
<td class="wht cl"><a href="#1530630372" >Assertions</a></td>
<td class="wht cl rt">16</td>
<td class="s10 cl rt">16</td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">16</td>
<td class="s10 cl rt">100.00</td>
</tr><tr>
<td class="wht cl"><a href="#232670649" >Cover properties</a></td>
<td class="wht cl rt">0</td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
</tr><tr>
<td class="wht cl"><a href="#990611678" >Cover sequences</a></td>
<td class="wht cl rt">0</td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
<td class="wht cl rt">0</td>
<td class="wht cl"></td>
</tr><tr>
<td class="wht cl"><b>Total</b></td>
<td class="wht cl rt">16</td>
<td class="s10 cl rt">16</td>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">16</td>
<td class="s10 cl rt">100.00</td>
</tr></table><br clear=all>
<br clear=all>
<hr>
<br clear=all>
<a name="1530630372"></a>
<b>Assertion Details</b><br clear=all>
<br clear=all>
<table align=left class="sortable noborder">
<tr class="sortablehead">
<td class="alfsrt">Name</td><td>Attempts</td><td>Real Successes</td><td>Failures</td><td>Incomplete</td></tr><tr>
<td class="wht cl"><a name="397961344"></a>
\ISO14443_3aTbSequence::check_state .isActive</td>
<td class="s9 cl rt">5673</td>
<td class="s9 cl rt">5673</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="424282958"></a>
\ISO14443_3aTbSequence::check_state .isActiveStar</td>
<td class="s9 cl rt">3702</td>
<td class="s9 cl rt">3702</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="714252443"></a>
\ISO14443_3aTbSequence::check_state .isHalt</td>
<td class="s9 cl rt">19082</td>
<td class="s9 cl rt">19082</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1065332110"></a>
\ISO14443_3aTbSequence::check_state .isIdle</td>
<td class="s9 cl rt">19088</td>
<td class="s9 cl rt">19088</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="964891167"></a>
\ISO14443_3aTbSequence::check_state .isProtocol1</td>
<td class="s9 cl rt">1502</td>
<td class="s9 cl rt">1502</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="756192864"></a>
\ISO14443_3aTbSequence::check_state .isProtocol2</td>
<td class="s9 cl rt">13003</td>
<td class="s9 cl rt">13003</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="246287959"></a>
\ISO14443_3aTbSequence::check_state .isReady</td>
<td class="s9 cl rt">38121</td>
<td class="s9 cl rt">38121</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="57330715"></a>
\ISO14443_3aTbSequence::check_state .isReadyStar</td>
<td class="s9 cl rt">32164</td>
<td class="s9 cl rt">32164</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1853956851"></a>
\ISO14443_3aTbSequence::sequence_callback .ecSent.checkCRC.crcOK</td>
<td class="s9 cl rt">68193</td>
<td class="s9 cl rt">68193</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="720138011"></a>
\ISO14443_3aTbSequence::sequence_callback .ecSent.forwadedTo14443_4a.checkForwardedPkt.iso144434aAsExpected</td>
<td class="s9 cl rt">2505</td>
<td class="s9 cl rt">2505</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1510979025"></a>
\ISO14443_3aTbSequence::sequence_callback .ecSent.forwardedAsExpected</td>
<td class="s9 cl rt">125190</td>
<td class="s9 cl rt">125190</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1417503872"></a>
part4Req</td>
<td class="s9 cl rt">124628763</td>
<td class="s9 cl rt">1983</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1033113167"></a>
rtsStaysLowDuringRx</td>
<td class="s9 cl rt">124628763</td>
<td class="s9 cl rt">125190</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="1495522768"></a>
rtsStaysLowUntilNextEOC</td>
<td class="s9 cl rt">124628763</td>
<td class="s9 cl rt">80660</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">1</td>
</tr><tr>
<td class="wht cl"><a name="1673402237"></a>
tagActive</td>
<td class="s9 cl rt">124628763</td>
<td class="s9 cl rt">124628763</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr><tr>
<td class="wht cl"><a name="759159827"></a>
triggerBlock.fdtTime</td>
<td class="s9 cl rt">80660</td>
<td class="s9 cl rt">80660</td>
<td class="s9 cl rt">0</td>
<td class="wht cl rt">0</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_40">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
    <li>
      <a href="#Assert">Assert</a>    </li>
  </ul>
  <ul name="tag_iso14443_3a_tb">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
    <li>
      <a href="#Assert">Assert</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
